# 20주차 이론

## 동적계획법

전체 문제를 한 번에 해결하는 것이 아니라 작은 부분 문제들을 해결하고, 이것들을 활용하여 전체 문제를 해결하는 방법이다. 하지만 부분 문제를 활용하여 전체 문제를 해결했다고 해서 반드시 동적 계획법이 효율적인 것은 아니다. 동적 계획법을 효율적으로 활용하려면 아래 두 가지 조건을 만족해야한다.

- 큰 문제를 작은 믄제로 나누었을 때 동일한 작은 문제가 반복해서 등장
- 큰 문제의 해결책은 작은 문제의 해결책의 합으로 구성되어야 한다

## 점화식 세우기와 동적 계획법

1. 문제를 해결하는 해가 이미 있다고 가정
2. 종료 조건을 설정
3. 과정 1, 2를 활용해 점화식을 세운다.

### 점화식 구현: 재귀 활용

재귀를 활용해서 점화식을 구현하는 방법이다. 

```jsx
Fact(n) {
	if(n이 1이면) 1 반환 // 종료 조건
	else Fact(n-1) * n 반환 // 일반향
}
```

이 방식은 함수를 계속하여 재귀 호출하므로 스택 메모리에 재귀 호출한 함수들이 모두 쌓이는 부담이 존재한다. 호출한 함수가 많으면 많을수록 스택 메모리에 함수 호출 정보가 많이 쌓인다. 그래서 입력값이 크다면 메모리 한계로 런타임 오류가 발생할 수 있다. 

### 메모이제이션 활용

메모이제이션은 이미 계산한 값을 저장해두었다가 이후 쓸 일이 있을 때 활용하는 개념으로 Fact(5)를 계산하는 과정에서 중간에 호출한 Fact(4), Fact(3), 의 해를 메모이제이션한다면 이후에는 같은 연산이 있을 때 반복하지 않아도 된다. 

### 재귀 + 메모이제이션
```jsx
fibodata[1....N] // 메모이제이션을 위한 배열 선언, 0으로 초기화
fibo(n) { // 함수를 정의
	if(fibodata[n] != 0 )fibodata[n] // 메모이제이션 활용
	if(n이 2 이하이면) fibodata[n] // 메모이제이션, 종료 조건
	else fibodata[n]에 fibo(n-1)+fibo(n-2) 삽입 // 메모이제이션, 일반향
}

fibodata[n] 반환
```