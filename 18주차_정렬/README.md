# 18주차 이론

## 정렬

정렬(sort)이란 사용자가 정의한 순서로 데이터를 나열하는 것을 말한다.

> **_정렬이 필요한 이유_**

데이터를 정렬하면 원하는 데이터를 쉽게 찾을 수 있다. 데이터를 정렬하면 데이터의 값을 보거나 비교할 필요 없이 원하는 데이터를 빠르게 찾을 수 있다. 이처럼 **정렬은 알고리즘의 효율을 크게 높여준다.**

## 삽입 정렬

삽입 정렬(insertion sort)은 데이터의 전체 영역에서 정렬된 영역과 정렬되지 않은 영역을 나누고 정렬되지 않은 영역의 값을 정렬된 영역의 적절한 위치로 놓으며 정렬한다.

![Insertion-sort-example-300px.gif](./images/Insertion-sort-example.gif)

삽입 정렬의 시간 복잡도 :

- 최악의 경우 $*O(N2)*$
- 이미 정렬이 되어 있는 최선의 경우 $*O(N)*$

[코드](./solutions/inssertSort.js)

### 병합 정렬

병합 정렬(merge sort)은 정렬되지 않은 영역을 쪼개서 각각의 영역을 정렬하고 이를 합치면 정렬한다.

1. **Divide (분할)**

   배열을 절반씩 계속 나누기 → 길이 1이 될 때까지

2. **Conquer (정복)**

   길이 1 배열은 이미 정렬되어 있다고 봄

3. **Merge (병합)**

   2개의 정렬된 배열을 합치는데, **작은 값부터 순서대로 병합**

![Merge-sort-example-300px.gif](./images/Merge-sort-example.gif)

병합 정렬의 핵심은 ‘병합할 때 *부분 정렬하는 부분을 어떻게 구현*해야 하는가?’이다.

1. 각 데이터의 첫 번째 원소를 가리키는 포인터를 만든다
   1. 포인터가 가리키는 두 값 중 작은 값을 선택해 새 저장 공간에 저장한다.
   2. 값이 선택된 포인터는 다음 위치의 값을 가리킨다.
2. 새 저장 공간에 하나의 데이터가 완전히 저장될 때까지 과정 1을 반복한다.
   1. 저장할 값이 남은 데이터의 값을 순서대로 새로운 저장 공간에 저장한다.
   2. 새로운 저장 공간에 두 개의 데이터가 정렬된 상태로 저장된다.
3. 새로운 저장소에 저장된 값의 개수와 초기에 주어진 데이터에 들어 있는 값의 개수가 같을 때까지 과정 1,2를 반복한다.

```jsx
// 분할 과정
[5,2,4,6,1,3]
=>
[5,2,4] + [6,1,3]
=> [5,2] + [4] + [6,1] + [3]
=> [5] [2] [4] [6] [1] [3]

// 병합 과정
[5] + [2] => [2,5]
[6] + [1] => [1,6]

[2,5] + [4] => [2,4,5]
[1,6] + [3] => [1,3,6]

[2,4,5] + [1,3,6]
=> [1,2,3,4,5,6]

```

병합 정렬의 시간 복잡도:

더 이상 나눌 수 없을 때까지 분할하므로 분할은 log₂ N번 진행한다. 정복은 다시 병합하며 정렬하는 과정으로 데이터가 N개이면 결국 N번 병합한다.

분할과 정복을 종합하면 총 N log₂ N번 연산하므로 **시간 복잡도는 $O(NlogN)$**이 된다.

[코드](./solutions/mergeSort.js)

## 힙정렬

힙 정렬(heap sort)은 힙이라는 자료구조를 사용해 정렬한다. 먼저 주어진 데이터로 힙을 구축해야한다.

힙이란?

특정 규칙이 있는 이진트리이다.

- 최대힙: 부모 노드가 자식 노드보다 크다.
- 최소힙: 부모 노드가 자식 노드보다 작다.

### 최대힙 구축 방법

1. 현재 노드와 자식의 노드 값을 비교한다.
   1. 현재 노드 값이 가장 큰 값이 아니면 자식 노드 중 가장 큰 값과 현재 노드의 값을 바꾼다.
   2. 만약 자식 노드가 없거나 현재 노드의 값이 가장 크면 연산을 종료한다.
2. 맞바꾼 자식 노드의 위치를 현재 노드로 하여 과정 1을 반복한다.

### 구축한 최대힙 정렬 방법

최대힙에서 힙 정렬 방식은 루트 노드가 가장 큰 값이므로 해당 값을 저장하기만 하면 된다. 그러나 루트 노드의 값을 뺀 이후 최대힙을 유지하는 것이 중요한데 루트 노드 없이 트리를 유지할 수 없기 때문에 **루트 노드를 마지막 노드와 바꾼 후 해당 노드는 정렬이 되었다고 생각하고 힙에서 제거**한다. 그리고 다시 최대힙 구축을 하여 이 과정을 반복한다.

![Heapsort-example.gif](./images/Heapsort-example.gif)

힙 정렬 시간 복잡도:

정렬되지 않은 값 N개를 힙으로 나타내면 높이가 logN인 트리가 된다. 데이터는 N개 이므로 힙 정렬의 시간 복잡도는 $O(N logN)$이 된다.

[코드](./solutions/heapSort.js)

## 우선순위 큐

우선순위 큐는 우선운위가 높은 데이터부터 먼저 처리하는 큐이다. 큐는 큐인데 우선 순위에 따라 팝을 하는 큐로 데이터의 값이 작을수록 우선순위가 높을 때의 우선순위 큐는 3, 1 순서로 데이터를 푸시하면 팝은 1, 3 순서로 한다. 우선순위 큐의 내부 동작은 힙과 매우 유사하므로 구현시 힙을 활용하는 것이 효율적이다.

### 우선순위 큐의 동작방식

1. 빈 우선순위 큐를 하나 선언한다. 형태는 큐와 동일
2. 3을 삽입한다. 빈 큐이므로 별다른 우선순위를 생각하지 않고 맨 앞에 푸시한다.
3. 이어서 1을 삽입한다. 1은 3보다 작으므로 우선순위가 높다. 1을 3 앞으로 삽입한다.
4. pop을 실행하면 3 앞에 1을 삽입했으므로 1이 나온다.

우선순위 큐가 활용되는 분야

- 작업 스케줄링 : 운영체제에서 프로세스나 스레드의 실행 순서를 결정할 때 우선순위 큐를 활용해서 중요한 작업을 먼저 처리한다.
- 응급실 대기열 : 환자의 진료 우선순위를 결정하고, 중증의 환자를 먼저 치료한다.
- 네트워크 트래픽 제어 : 패킷 스케불링 및 트래픽 관리에서 중요하거나 긴급한 패킷을 먼저 처리한다.
- 교통 네트워크 최적화 : 교통 체계를 분석하고 최적화하기 위한 최단 경로 알고리즘을 구현하기 위해 활용한다.

## 위상 정렬

위상 정렬(topological sort)은 일의 순서가 있는 작업을 순서에 맞춰 정렬하는 알고리즘이다. 위상 정렬은 일의 순서가 중요하므로 반드시 간선의 방향이 있어야한다. 방향 비순환 그래프(DAG, directed acyclic graph)에서만 사용할 수 있다.

위상 정렬과 진입차수

위상 정렬은 자신을 향한 화살표 개수를 진입차수로 정의하여 진행한다. 진입차수는 자신을 향한 화살표의 개수이다. 만약 진입차수가 0이라고 하면 자신을 향한 화살표가 없다는 뜻이다. 즉, 선행작업이 필요없는 바로 할 수 있는 일을 나타낸다.

위상 정렬 과정

위상 정렬은 진입차수가 0인 일을 해결하고 관련된 작업의 진입차수를 1씩 낮추면서 새롭게 진입차수가 0이 된 작업들을 해결하는 식으로 진행한다. 이때 큐를 활용하여 구현한다. 지입차수가 0인 작업을 일단 전부 큐에 넣고 하나씩 팝하면서 해당 작업과 연결되어 있는 작업들의 진입차수를 줄인다. 그러면서 진입차수가 0이 된 작업을 큐에 넣는다.

위상 정렬의 시간 복잡도:

위상정렬은 모든 정점과 간선을 딱 한번씩만 지나므로 시간복잡도는 $O(|V|+|E|)$가 된다.

## 계수 정렬

계수 정렬(counting sort)은 데이터에 의존하는 정렬 방식이다. 데이터의 빈도수로 정렬하는 방식으로 각 데이터의 빈도수를 정리한 후 우선 순위가 높은 데이터부터 빈도수만큼 출력하는 것이 계수 정렬이다.

한계

빈도수 배열에 저장할 값의 범위가 듬성듬성 있거나 음수가 있으면 계수정렬하기 어려워진다.

계수정렬의 시간복잡도:

값이 N개인 데이터를 세는 과정은 전체 데이터를 한 번씩 체크하므로 N번 탐색한다. 값의 최솟값 ~ 최댓값 범위 크기가 K라면 빈도수 배열에서 K+1만큼 탐색해야 하므로 계수 정렬의 시간 복잡도는 $O(N+K)$이다.

---

## 정수 내림차순 배치하기 시간 복잡도 비교

[코드](./solutions/정수내림차순으로배치하기.js)

```jsx
sort 실행 시간: 33.8264 ms
insert 실행 시간: 3959.1875 ms
merge 실행 시간: 22.5424 ms
heap 실행 시간: 16.8745 ms
```
